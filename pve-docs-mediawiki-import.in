#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;

use IO::File;
use File::Basename;
use MediaWiki::API;
use HTML::Parser;

use JSON;

my $data_str = "";
while (<main::DATA>) { $data_str .= $_; }

my $fileinfo = decode_json($data_str);

my $config_fn = "/root/.pve-docs"; # format 'username:pw'

my $fh = IO::File->new("$config_fn")
    || die "Please configure the mediawiki user/passswd in '$config_fn'\n";

my $api_url = "https://pve.proxmox.com/mediawiki/api.php";

my $config = <$fh>;
chomp $config;

my ($username, $passwd) = split(':', $config, 2);

my $mw = MediaWiki::API->new();
$mw->{config}->{api_url} = $api_url;

# log in to the wiki
$mw->login({ lgname => $username, lgpassword => $passwd })
    || die $mw->{error}->{code} . ': ' . $mw->{error}->{details};

sub update_page {
    my ($pagename, $filename, $category) = @_;

    print "update mediawiki page: $pagename\n";

    my $ref = $mw->get_page({ title => $pagename });
    my $page = $ref->{'*'} || '';

    my $pve_content = "<!-- Do not edit - this is autogenerated content -->\n";

    $pve_content .= "{{#pvedocs:$filename}}\n";
    $pve_content .= "[[Category:$category]]\n" if $category;

    my $starttag = '<!--PVE_IMPORT_START_MARKER-->';
    my $endtag = '<!--PVE_IMPORT_END_MARKER-->';

    $pve_content .= "<pvehide>\n";

    my $parser_opts = {
        api_version => 3,
        text_h => [sub { $pve_content .= shift }, "text"],
    };
    my $parser = HTML::Parser->new(%$parser_opts);
    $parser->ignore_elements(qw(script style));

    my $fh = IO::File->new("/usr/share/pve-docs/$filename", "r")
        or die "unable to open file '$filename' - $!\n";
    while (defined(my $line = <$fh>)) {
        $parser->parse($line);
    }
    $pve_content .= "</pvehide>\n";

    $pve_content =~ s/\s+$//gm;

    chomp $pve_content;

    if ($page =~ m/^(.*)$starttag\n.*\n$endtag\n?(.*)$/s) {
        my ($top_content, $bottom_content) = ($1, $2);
        $page = $top_content;
        $page .= "$starttag\n";
        $page .= $pve_content;
        $page .= "\n$endtag\n";
        $page .= $bottom_content;
    } elsif ($page =~ m/(.*)\{\{#pvedocs:.*?\}\}(.*)$/) {
        # old style
        my ($top_content, $bottom_content) = ($1, $2);
        chomp $top_content;
        chomp $bottom_content;
        $page = $top_content;
        $page .= "$starttag\n";
        $page .= $pve_content;
        $page .= "\n$endtag\n";
        $page .= $bottom_content;
    } else {
        $page = "$starttag\n$pve_content\n$endtag\n$page";
    }

    my $timestamp = $ref->{timestamp};
    my $wcmd = {
        action => 'edit',
        title => $pagename,
        basetimestamp => $timestamp, # to avoid edit conflicts
        text => $page,
    };

    $mw->edit($wcmd)
        || die $mw->{error}->{code} . ': ' . $mw->{error}->{details};
}

my $cat_refdoc = "Reference Documentation";

my $docs = {};
foreach my $source (sort keys %{ $fileinfo->{toplevel}->{wiki} }) {
    my $title = $fileinfo->{titles}->{wiki}->{$source};
    my $filename = $fileinfo->{outfile}->{wiki}->{$source}
        || die "found no file name mapping for '$source'";

    my $path = "/usr/share/pve-docs/$filename";
    die "no such file '$path'" if !-f $path;

    update_page($title, $filename, $cat_refdoc);
}

# also update 'Get support' page, because this is used since a long
# time and is referenced from outside
update_page("Get support", 'getting-help-plain.html', 'HOWTO');

__END__
